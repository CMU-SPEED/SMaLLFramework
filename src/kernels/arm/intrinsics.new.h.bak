#include <arm_neon.h>

// https://developer.arm.com/architectures/instruction-sets/intrinsics/

//Architecture specific tiling params


// __m256 a_reg,b0,b1,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13;

// Initializations

// float32x4_t vectorizes C_ob dim: [W_ob, C_ob] -> [W_ob, C_ob/SIMD, SIMD].
// assume SIMD == 4 and vec type is float.
// otherwise, SIMD = Neon bit width (128) / data type size.



#define DEF_TILE_C(W_ob, C_ob)              \
  float c_tile[W_ob * C_ob];                \
  float32x4_t c_tile_v[W_ob * (C_ob/SIMD)];

#define DEF_END_C(W_ob, C_ob)               \
  float c_tile[W_ob * C_ob];                \
  float32x4_t c_tile_v[W_ob * (C_ob/SIMD)];
  
// === Initialize C tile to zero ==============================================
#define ZERO_TILE_C(W_ob, C_ob)                                               \
  for (uint32_t kk = 0; kk < W_ob; kk++)                                      \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
    {                                                                         \
      c_tile_v[kk * (C_ob/SIMD) + jj] = vdupq_n_f32(0);                       \
    }                                                                         \
  }

#define ZERO_END_C(_W_ob, C_ob)                                               \
  for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob; jj++)                                    \
    {                                                                         \
      c_tile[kk * C_ob + jj] = {};                                            \
    }                                                                         \
  }
// for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
// {                                                                           \
//   for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
//   {                                                                         \
//     c_tile_v[kk * (C_ob/SIMD) + jj] = vdupq_n_f32(0);                       \
//   }                                                                         \
// }
// === End Initialize C tile to zero ==========================================

// === Loads ==================================================================
#define LOAD_TILE_C(O, W_ob, C_ob)                                            \
  for (uint32_t kk = 0; kk < W_ob; kk++)                                      \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
    {                                                                         \
      c_tile_v[kk * (C_ob/SIMD) + jj] = vld1q_f32(O + kk * C_ob + jj * SIMD); \
    }                                                                         \
  }

#define LOAD_END_C(O, _W_ob, C_ob)                                            \
  for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob; jj++)                                    \
    {                                                                         \
      c_tile[kk * C_ob + jj] = O[kk * C_ob + jj];                             \
    }                                                                         \
  }
// for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
// {                                                                           \
//   for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
//   {                                                                         \
//     c_tile_v[kk * (C_ob/SIMD) + jj] = vld1q_f32(O + kk * C_ob + jj * SIMD); \
//   }                                                                         \
// }

#define LOAD_TILE_C_strided(O, step, W_ob, C_ob)                              \
  for (uint32_t kk = 0; kk < W_ob; kk++)                                      \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
    {                                                                         \
      c_tile_v[kk * (C_ob/SIMD) + jj] = vld1q_f32(O + kk * step + jj*SIMD);   \
    }                                                                         \
  }

#define LOAD_END_C_strided(O, step, _W_ob, C_ob)                              \
  for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob; jj++)                                    \
    {                                                                         \
      c_tile[kk * C_ob + jj] = O[kk * step + jj];                             \
    }                                                                         \
  }
// for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
// {                                                                           \
//   for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
//   {                                                                         \
//     c_tile_v[kk * (C_ob/SIMD) + jj] = vld1q_f32(O + kk * step + jj*SIMD);   \
//   }                                                                         \
// }

// === End Loads ==============================================================

                          
// === Stores =================================================================
#define STORE_TILE_C(O, W_ob, C_ob)                                           \
  for (uint32_t kk = 0; kk < W_ob; kk++)                                      \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
    {                                                                         \
      vst1q_f32(O + kk * C_ob + jj * SIMD, c_tile_v[kk * (C_ob/SIMD) + jj]);  \
    }                                                                         \
  }

#define STORE_END_C(O, _W_ob, C_ob)                                           \
  for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob; jj++)                                    \
    {                                                                         \
      O[kk * C_ob + jj] = c_tile[kk * C_ob + jj];                             \
    }                                                                         \
  }
// for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
// {                                                                           \
//   for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
//   {                                                                         \
//     vst1q_f32(O + kk * C_ob + jj * SIMD, c_tile_v[kk * (C_ob/SIMD) + jj]);  \
//   }                                                                         \
// }

// === End Stores =============================================================

// === Convolution ============================================================
#define CONV_TILE_C(step, a, b, W_ob, C_ob)                                   \
  float32x4_t bv[C_ob/SIMD];                                                  \
  for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                                 \
  {                                                                           \
      bv[jj] = vld1q_f32(b + jj*SIMD);                                        \
  }                                                                           \
  for (uint32_t kk = 0; kk < W_ob; kk++)                                      \
  {                                                                           \
    float32x4_t av = vld1q_dup_f32(a + kk * step);                            \
    for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
    {                                                                         \
      c_tile_v[kk * (C_ob/SIMD) + jj] =                                       \
      vfmaq_f32(c_tile_v[kk * (C_ob/SIMD) + jj], av, bv[jj]);                 \
    }                                                                         \
  }

#define CONV_END_C(step, a, b, c_cur, _W_ob, C_ob)                            \
  for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob; jj++)                                    \
    {                                                                         \
      c_cur[kk * C_ob + jj] += a[kk * step] * b[jj];                          \
    }                                                                         \
  }
// for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
// {                                                                           \
//   float32x4_t av = vld1q_dup_f32(a + kk * step);                            \
//   for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
//   {                                                                         \
//     float32x4_t bv = vld1q_f32(b + jj*SIMD);                                \
//     c_tile_v[(c_cur + kk) * (C_ob/SIMD) + jj] =                             \
//       vfmaq_f32(c_tile_v[(c_cur + kk) * (C_ob/SIMD) + jj], av, bv);         \
//   }                                                                         \
// }
// === End Convolution ========================================================


// === Max Pooling/ReLU =======================================================
#define MAX_TILE_C(step, a, W_ob, C_ob)                                       \
  for (uint32_t kk = 0; kk < W_ob; kk++)                                      \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
    {                                                                         \
      float32x4_t av = vld1q_f32(a + kk * step + jj * SIMD);                  \
      c_tile_v[kk * (C_ob/SIMD) + jj] =                                       \
        vmaxq_f32(av, c_tile_v[kk * (C_ob/SIMD) + jj]);                       \
    }                                                                         \
  }

#define MAX_END_C(step, a, b, c_cur, W_last, C_ob)                            \
  for (uint32_t kk = 0; kk < W_last; kk++)                                    \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob; jj++)                                    \
    {                                                                         \
      c_cur[kk * C_ob + jj] =                                                 \
        c_cur[kk * C_ob + jj] > a[kk * step + jj] ?                           \
        c_cur[kk * C_ob + jj] : a[kk * step + jj];                            \
    }                                                                         \
  }
// for (uint32_t kk = 0; kk < W_last; kk++)                                    \
// {                                                                           \
//   for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
//   {                                                                         \
//     float32x4_t av = vld1q_f32(a + kk * step + jj * SIMD);                  \
//     c_tile_v[(c_cur + kk) * (C_ob/SIMD) + jj] =                             \
//       vmaxq_f32(av, c_tile_v[(c_cur + kk) * (C_ob/SIMD) + jj]);             \
//   }                                                                         \
// }
// === End Max Pooling/ReLU ===================================================

// === Depthwise Convolution ==================================================
#define DW_TILE_C(step, a, b, W_ob, C_ob)                                     \
  float32x4_t bv[C_ob/SIMD];                                                  \
  for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                                 \
  {                                                                           \
      bv[jj] = vld1q_f32(b + jj*SIMD);                                        \
  }                                                                           \
  for (uint32_t kk = 0; kk < W_ob; kk++)                                      \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
    {                                                                         \
      float32x4_t av = vld1q_f32(a + kk * step + jj*SIMD);                    \
      c_tile_v[kk * (C_ob/SIMD) + jj] =                                       \
        vfmaq_f32(c_tile_v[kk * (C_ob/SIMD) + jj], av, bv[jj]);               \
    }                                                                         \
  }

// TODO: is this tested?
#define DW_END_C(step, a, b, c_cur, _W_ob, C_ob)                              \
  for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
  {                                                                           \
    for (uint32_t jj = 0; jj < C_ob; jj++)                                    \
    {                                                                         \
      c_cur[kk * C_ob + jj] += a[kk * step + jj] * b[jj];                     \
    }                                                                         \
  }
// for (uint32_t kk = 0; kk < _W_ob; kk++)                                     \
// {                                                                           \
//   for (uint32_t jj = 0; jj < C_ob/SIMD; jj++)                               \
//   {                                                                         \
//     float32x4_t av = vld1q_f32(a + kk * step + jj*SIMD);                    \
//     float32x4_t bv = vld1q_f32(b +             jj*SIMD);                    \
//     c_tile_v[(c_cur + kk) * (C_ob/SIMD) + jj] =                             \
//       vfmaq_f32(c_tile_v[(c_cur + kk) * (C_ob/SIMD) + jj], av, bv);         \
//   }                                                                         \
// }
// === End Depthwise Convolution ==============================================

// TODO: is this tested?
// AVG Pooling
#define ADD_TILE_C_G(I, W_ob_g, C_ob)              \
  for (uint32_t mm = 0; mm < W_ob_g; mm++)         \
  {                                                \
    for (uint32_t kk = 0; kk < C_ob; kk++)         \
    {                                              \
      c_tile[mm * C_ob + kk] += I[mm * C_ob + kk]; \
    }                                              \
  }

#define ADD_LAST_C_G(I, W_last, C_ob)      \
  float *i_pixel = I;                      \
  float *c_pixel = c_tile;                 \
  for (uint32_t mm = 0; mm < W_last; mm++) \
  {                                        \
    float *c_channel = c_pixel;            \
    float *i_channel = i_pixel;            \
    for (uint32_t kk = 0; kk < C_ob; kk++) \
    {                                      \
      *c_channel += *i_channel;            \
      c_channel++;                         \
      i_channel++;                         \
    }                                      \
    c_pixel += C_ob;                       \
    i_pixel += C_ob;                       \
  }

#define REDUCE_div_C(O, d, W_ob_g, C_ob)   \
{ float *c_pixel = c_tile;                 \
  float *O_channel = O;                    \
  float *c_channel = c_pixel;              \
  for (uint32_t mm = 0; mm < W_ob_g; mm++) \
  {                                        \
    float *O_channel = O;                  \
    float *c_channel = c_pixel;            \
    for (uint32_t kk = 0; kk < C_ob; kk++) \
    {                                      \
      *O_channel += *c_channel;            \
      O_channel++;                         \
      c_channel++;                         \
    }                                      \
    c_pixel += C_ob;                       \
  }                                        \
  O_channel = O;                           \
  for (uint32_t kk = 0; kk < C_ob; kk++)   \
  {                                        \
    *O_channel *= d;                       \
    O_channel++;                           \
  }\
}

#define REDUCE_C(O, W_ob_g, C_ob)            \
  {                                          \
    for (uint32_t mm = 0; mm < W_ob_g; mm++) \
    {                                        \
      for (uint32_t kk = 0; kk < C_ob; kk++) \
      {                                      \
        O[kk] += c_tile[mm * C_ob + kk];     \
      }                                      \
    }                                        \
  }

#define REDUCE_C_last(O, W_last, C_ob)       \
  {                                          \
    float *c_pixel = c_tile;                 \
    float *O_channel = O;                    \
    float *c_channel = c_pixel;              \
    for (uint32_t mm = 0; mm < W_ob_g; mm++) \
    {                                        \
      float *O_channel = O;                  \
      float *c_channel = c_pixel;            \
      for (uint32_t kk = 0; kk < C_ob; kk++) \
      {                                      \
        *O_channel += *c_channel;            \
        O_channel++;                         \
        c_channel++;                         \
      }                                      \
      c_pixel += C_ob;                       \
    }                                        \
  }

  